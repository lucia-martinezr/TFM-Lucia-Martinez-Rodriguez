library(dplyr)
library(readxl)
# Carga de datos clínicos
clin <- read_excel('C:/Users/lulim/OneDrive/Escritorio/SCAN B Data/SCANB_clinical_data_original_41523_2022_465_MOESM2_ESM.xlsx')
dim(clin) # 9206 87
# Carga de datos de conteo (FPKM)
load('C:/Users/lulim/OneDrive/Escritorio/SCAN B Data/SCANB.9206.genematrix_noNeg.Rdata')
ls()
dim(SCANB.9206.genematrix_noNeg) # 19675  9206
# Filtrado de datos: Nos quedamos sólo con muestras de TNBC.
clin_tnbc <- clin %>% filter(ClinGroup == "TNBC")
unique_patients <- unique(clin_tnbc$Patient) #715 pacientes únicos
id_tnbc <- clin_tnbc[[1]]
scanb <- as.data.frame(SCANB.9206.genematrix_noNeg)
scanb_tnbc <- scanb %>% select(all_of(id_tnbc))
# Nos quedan 874 muestras y 19675 genes.
# Filtrado de datos: nos quedamos con solo una muestra por paciente. Eliminación de replicados técnicos.
## Contar la cantidad de ocurrencias de cada valor de la columna Patient
patient_counts <- table(clin_tnbc$Patient)
## Identificar los pacientes que aparecen más de una vez
multiple_patients <- names(patient_counts[patient_counts > 1]) #128 pacientes tienen replicados en el dataset.
repeated_patients <- clin_tnbc[clin_tnbc$Patient %in% multiple_patients, ]
## Uso de FRACTION DUPLICATION como criterio de selección de muestras. Se mantiene el de menor valor.
filtered_clin_tnbc <- do.call(rbind, lapply(split(clin_tnbc, clin_tnbc$Patient), function(group) {
if (nrow(group) > 1) {
closest_row <- group[which.min(group$FRACTION_DUPLICATION), ]
return(closest_row)
} else {
return(group)
}
}))
# Filtrar scanb_tnbc
filtered_id_tnbc <- filtered_clin_tnbc[[1]]
filtered_scanb_tnbc <-scanb_tnbc %>% select(all_of(filtered_id_tnbc))
filtered_scanb_tnbc <- as.data.frame(t(filtered_scanb_tnbc))
# Filtrado de datos: eliminación de los genes con un FPKM de 0 en más del 20% de muestras.
# zero_sum_columns <- sum(colSums(filtered_scanb_tnbc) == 0)  ### 117 columnas tienen exactamente 0 FPKM en total.
threshold <- nrow(filtered_scanb_tnbc) * 0.2
filtered_scanb_tnbc <- filtered_scanb_tnbc %>%
select(where(~ sum(. == 0) <= threshold)) # Se me reduce en 3972 columnas. Ahora quedan 15703 genes.
# Filtrado de datos: eliminación de valores constantes. (Necesario para Corradjust)
kk <- filtered_scanb_tnbc[, sapply(filtered_scanb_tnbc, function(column) length(unique(column)) > 1)]
dim(kk)==dim(filtered_scanb_tnbc) # No hay columnas constantes
# Intersección de los genes con los conjuntos de datos de validación externa.
# Variance Stabilizing Transformation (VST)
write.table(filtered_scanb_tnbc, 'C:/Users/lulim/OneDrive/Documentos/GitHub/TFM-Lucia-Martinez-Rodriguez/data/ext_data/scanb_tnbc.tsv', sep = '/t')
write.table(filtered_clin_tnbc, 'C:/Users/lulim/OneDrive/Documentos/GitHub/TFM-Lucia-Martinez-Rodriguez/data/ext_data/clin_tnbc.tsv', sep = '/t')
write.table(filtered_scanb_tnbc,
'C:/Users/lulim/OneDrive/Documentos/GitHub/TFM-Lucia-Martinez-Rodriguez/data/ext_data/scanb_tnbc.tsv',
sep = '\t',
row.names = TRUE,
col.names = NA)
write.table(filtered_clin_tnbc,
'C:/Users/lulim/OneDrive/Documentos/GitHub/TFM-Lucia-Martinez-Rodriguez/data/ext_data/clin_tnbc.tsv',
sep = '\t',
row.names = TRUE,
col.names = NA)
View(filtered_clin_tnbc)
View(filtered_clin_tnbc)
View(filtered_scanb_tnbc)
View(filtered_clin_tnbc)
View(filtered_scanb_tnbc)
# Cargar/instalar paquetes necesarios usando pacman
if (!requireNamespace("pacman", quietly = TRUE)) {
install.packages("pacman")
}
pacman::p_load(biomaRt, dplyr, readr)
# 1. Conectar con Ensembl usando biomaRt
cat("Conectando a Ensembl...\n")
# Usar una versión específica de Ensembl puede ser bueno para la reproducibilidad
# Para encontrar la versión más reciente o una específica, puedes visitar archive.ensembl.org
# O simplemente usar la versión actual por defecto:
# ensembl_mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl")
# O especificar un host de archivo si la conexión directa falla o para versiones antiguas:
ensembl_mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset = "hsapiens_gene_ensembl",
host = "https://www.ensembl.org") # o "https://dec2023.archive.ensembl.org" para una versión específica
cat("Conexión establecida.\n")
# 2. Obtener la información de los genes
# Atributos que queremos:
# - ensembl_gene_id: ID de Ensembl (sin versión)
# - external_gene_name: Símbolo del gen (lo que queremos como 'feature_name')
# - entrezgene_id: ID de Entrez (puede ser útil)
# - gene_biotype: Tipo de gen (para filtrar por 'protein_coding' si es necesario)
cat("Obteniendo datos de los genes desde biomaRt...\n")
gene_annotations <- getBM(
attributes = c("ensembl_gene_id",
"external_gene_name",
"entrezgene_id",
"gene_biotype"),
mart = ensembl_mart
)
cat("Datos de genes obtenidos. Número total de entradas:", nrow(gene_annotations), "\n")
# Inspeccionar las primeras filas y la estructura
print(head(gene_annotations))
str(gene_annotations)
output_dir <- "C:/Users/lulim/OneDrive/Documentos/GitHub/TFM-Lucia-Martinez-Rodriguez/data/dictionary" # Directorio de salida deseado
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE)
}
output_filename_tsv <- file.path(output_dir, "ensembl_hsapiens_gene_annotations.tsv")
output_filename_rds <- file.path(output_dir, "ensembl_hsapiens_gene_annotations.rds") # También guardamos como RDS por si acaso
cat("Guardando anotaciones en:", output_filename_tsv, "\n")
readr::write_tsv(gene_annotations, output_filename_tsv)
cat("Guardando anotaciones también en formato RDS:", output_filename_rds, "\n")
saveRDS(gene_annotations, file = output_filename_rds)
cat("Proceso completado. El archivo de anotaciones se ha guardado.\n")
# Desconectar (opcional, biomaRt no mantiene una conexión persistente de esa manera)
detach("package:biomaRt", unload = TRUE) # Pacman podría manejar esto o puedes dejarlo cargado.
View(gene_annotations)
gene_annotations <- getBM(
attributes = c("ensembl_gene_id",
"gene_symbol",
"entrezgene_id",
"gene_biotype"),
mart = ensembl_mart
)
# Creation of a gene dictionary
# Cargar/instalar paquetes necesarios usando pacman
if (!requireNamespace("pacman", quietly = TRUE)) {
install.packages("pacman")
}
pacman::p_load(biomaRt, dplyr, readr)
# 1. Conectar con Ensembl usando biomaRt
cat("Conectando a Ensembl...\n")
# Usar una versión específica de Ensembl puede ser bueno para la reproducibilidad
# Para encontrar la versión más reciente o una específica, puedes visitar archive.ensembl.org
# O simplemente usar la versión actual por defecto:
# ensembl_mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl")
# O especificar un host de archivo si la conexión directa falla o para versiones antiguas:
ensembl_mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset = "hsapiens_gene_ensembl",
host = "https://www.ensembl.org") # o "https://dec2023.archive.ensembl.org" para una versión específica
cat("Conexión establecida.\n")
# 2. Obtener la información de los genes
# Atributos que queremos:
# - ensembl_gene_id: ID de Ensembl (sin versión)
# - external_gene_name: Símbolo del gen (lo que queremos como 'feature_name')
# - entrezgene_id: ID de Entrez (puede ser útil)
# - gene_biotype: Tipo de gen (para filtrar por 'protein_coding' si es necesario)
cat("Obteniendo datos de los genes desde biomaRt...\n")
gene_annotations <- getBM(
attributes = c("ensembl_gene_id",
"gene_symbol",
"entrezgene_id",
"gene_biotype"),
mart = ensembl_mart
)
View(gene_annotations)
View(gene_annotations)
library(dplyr)
library(readxl)
# Carga de datos clínicos
clin <- read_excel('C:/Users/lulim/OneDrive/Escritorio/SCAN B Data/SCANB_clinical_data_original_41523_2022_465_MOESM2_ESM.xlsx')
dim(clin) # 9206 87
# Carga de datos de conteo (FPKM)
load('C:/Users/lulim/OneDrive/Escritorio/SCAN B Data/SCANB.9206.genematrix_noNeg.Rdata')
ls()
dim(SCANB.9206.genematrix_noNeg) # 19675  9206
# Filtrado de datos: Nos quedamos sólo con muestras de TNBC.
clin_tnbc <- clin %>% filter(ClinGroup == "TNBC")
unique_patients <- unique(clin_tnbc$Patient) #715 pacientes únicos
id_tnbc <- clin_tnbc[[1]]
scanb <- as.data.frame(SCANB.9206.genematrix_noNeg)
scanb_tnbc <- scanb %>% select(all_of(id_tnbc))
library(dplyr)
scanb_tnbc <- scanb %>% select(all_of(id_tnbc))
View(clin_tnbc)
View(scanb)
class(scanb)
scanb_tnbc <- scanb %>% select(all_of(id_tnbc))
as_tibble(scanb)
scanb_tnbc <- scanb %>% select(all_of(id_tnbc))
